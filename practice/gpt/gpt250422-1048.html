<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0 maximum-scale=1">
  <meta property="og:type" content="website">
  <meta property="og:title" content="">
  <meta property="og:url" content="">
  <meta property="og:description" content="">
  <meta property="og:image" content="public/img/common/img-share.png">
  <meta rel="shortcut icon" type="image/x-icon" href="../src/assets/img/icon/favicon.svg" size="16x16">
  <title>gpt250422-1048</title>
  <style>
    #info-container {
      position: relative;
      width: 600px;
      height: 500px;
      background: #f4f4f4;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.1);
    }

    .info-bubble {
      position: absolute;
      padding: 8px 16px;
      border-radius: 999px;
      max-width: 200px;
      background: #ddd;
      color: #333;
      opacity: 0;
      font-size: 14px;
      box-sizing: border-box;
      text-align: center;
      word-break: keep-all;
      line-height: 1.4;
      white-space: normal;
      /* transition: opacity 0.5s ease, transform 0.6s ease; */
      cursor: default;
      transition: opacity 0.5s ease, transform 0.6s ease, box-shadow 0.3s ease, font-weight 0.3s ease;
      /* transition: 0.5s ease; */
      opacity: 1;
      transform: translateY(0);
      box-shadow: 1px 3px 6px rgba(0, 0, 0, 0.1);
      z-index: 1;
    }


    /* 감정 구분 색상 */
    .posit {
      background-color: #d2f8ce;
      color: #245c1d;
    }

    .negat {
      background-color: #ffe0e0;
      color: #7d1f1f;
    }

    .neut {
      background-color: #fff6c5;
      color: #5a4d00;
    }

    .info-bubble.fade-in {
      /* opacity: 1; */
      animation: bounceIn 0.6s ease forwards;
    }

    .info-bubble.fade-out {
      opacity: 0;
      /* transition: opacity 1s ease; */
    }

    .info-bubble:hover {
      transform: scale(1.05);
      /* 👈 살짝 커짐 */
      z-index: 2;
      box-shadow: 1px 3px 8px rgba(0, 0, 0, 0.15);
      font-weight: 500;
    }

    @keyframes bounceIn {
      0% {
        transform: translateY(10px);
      }

      40% {
        transform: translateY(-8px);
      }

      70% {
        transform: translateY(4px);
      }

      100% {
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <section class="test-sec">
    <!-- code wrap -->
    <div class="c__wrap">
      <div class="wrapper">
        <div id="info-container"></div>
      </div>
    </div>
  </section>

  <section class="text-sec">

    <!-- question wrap -->
    <div class="q__wrap">
      <h3 class="q-title">메세지 버블 1-C차</h3>
      <div class="q-date">2503403_1048</div>
      <div class="q-subs">
        <p class="txt">
        <pre>
            페이지가 열리면 백에서 넘어 온 단순한 문장들을 받아서 800x800px의 컨테이너 내에 뿌려줄 거야.
일단 각 문장은 원형의 박스 안에 있어.
처음엔 빈 공간인데 1.5초마다 문장 박스가 페이드인할 거야.
문장 박스의 공간은 랜덤인데, 문장 박스마다 간격은 최소 4px은 떨어져 있어야해.
컨테이너 공간 내에서 4px 이상의 간격은 얼마든지 괜찮아.
문장 박스가 더 들어갈 자리가 없으면 생겨난 순서대로 페이드아웃되면서 다음 문장박스 들이 페이드인하지.
문장 박스의 갯수는 정해져있지 않아, 늘 달라질 수 있지.
하지만 문장 박스 너비 내에 모두 들어갈 수 있는 양이라면 위의 동작 패턴은 멈추면 돼.
          </pre>
        </p>
        <p class="txt added">
        <pre>
            우와 깔끔하고 좋다!
  그럼 좀 더 추가해보자.
  - 문장 길이에따라 버블 크기가 유동적으로 달라져.
  - 총 너비는 600x600px로 수정.
  - 버블이 나타날땐 페이드인하면서 살짝 위로 튕겼다가 아래로 살짝 튕기고 정지, 사라질때는 페이드 아웃.
  - 버블은 서로 겹치면 안돼. 최소 간격 3px 유지해줘.
          </pre>
        </p>
        <p class="txt added last">
        <pre>
          - 버블 내의 문장은 긍정과 부정과 중간, 이 세가지로 이뤄지거든? 긍정은 초록 부정을 빨강, 중간은 노란 계열의 색으로 버블의 배경을 넣어줘.
          - 긍정의 버블엔 .posit, 부정의 버블엔 .negat, 중간의 버블엔 .neut로 클래스를 추가해서 그걸로 구분해줘.
          - 참고로 버블내에 들어가는 문장을 보내주는 건 백엔드 동료야, 나와는 별개의 작업이니까 참고해서 작업해줘.
          - 버블 너비의 최대치는 padding 포함해서 200px이고 이를 넘어가면 줄넘김해줘.
          </pre>
        </p>
      </div>
    </div>

    <!-- answer wrap -->
    <div class="a__wrap">
      <div class="a-subs">
        <div class="a-txt">
          완벽하게 이해했어 요끼야!<br>
          이제 버블의 감정 구분 스타일과 너비 제한 및 줄바꿈 처리까지 추가해서 완성형으로 가보자! 😊
        </div>
        <!-- <div class="a-txt__box">
          <div class="a-txt-head">🎯 목표</div>
          <ul class="a-txt__list ul">
            <li class="a-txt__item">- 800x800 컨테이너 내에</li>
            <li class="a-txt__item">- 원형 문장 박스들을 랜덤 위치에 배치</li>
            <li class="a-txt__item">- 1.5초 간격으로 페이드인</li>
            <li class="a-txt__item">- 문장 박스끼리는 최소 4px 간격 유지</li>
            <li class="a-txt__item">- 공간 부족 시, 먼저 생긴 박스부터 페이드아웃 → 새로운 박스 페이드인</li>
            <li class="a-txt__item">- 문장 수는 유동적, 공간 내에 모두 들어가면 애니메이션 멈춤</li>
          </ul>
        </div> -->
      </div>
    </div>

    <!-- result wrap -->
    <div class="r__wrap">
      <div class="r-subs">
        <div class="r-txt">
          <pre>
            ✅ 요약 체크리스트

요구사항	✅ 반영 여부
600x600 컨테이너	✅
감정 구분 (긍정/부정/중간)	✅
색상 분리 (초록/빨강/노랑)	✅
.posit, .negat, .neut 클래스	✅
페이드인 + 튕김 애니메이션	✅
페이드아웃 삭제	✅
버블 너비 제한 및 줄넘김	✅
버블 간 최소 3px 간격 유지	✅
          </pre>
        </div>
        <div class="r-txt__box">
          <div class="r-txt-head">
            요끼야~ 여기에 더 추가하고 싶은 요소가 있다면 말만 해!<br>
            예를 들어:
          </div>
          <ul class="r-txt__list u">
            <li class="r-txt__item">- 각 감정마다 이모티콘 추가?</li>
            <li class="r-txt__item">- 마우스 hover 시 말풍선처럼 설명?</li>
            <li class="r-txt__item">- 애니메이션 속도 조절?</li>
            <!-- <li class="r-txt__item">✅ 아이템들의 높이가 다 달라도 문제없이 자연스럽게 작동</li> -->
          </ul>
          <div class="r-txt">마음껏 커스터마이징 해줄게! 💚💛❤️</div>
        </div>
      </div>
    </div>
  </section>

  <script>
    const container = document.getElementById('info-container');
    const containerW = 600;
    const containerH = 500;
    const margin = 3;
    let bubbles = [];
    let index = 0;

    // 백엔드로부터 받을 데이터 예시 (text + type)
    const sentences = [
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.무난한 결과입니다.무난한 결과입니다.무난한 결과입니다.무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
      { text: "잘 하고 있어요!", type: "posit" },
      { text: "조금만 더 신경 써주세요.", type: "negat" },
      { text: "무난한 결과입니다.", type: "neut" },
      { text: "정말 대단해요!", type: "posit" },
      { text: "지연이 발생했습니다.", type: "negat" },
      { text: "평균 수준이에요.", type: "neut" },
    ];

    function createBubble({ text, type }) {
      const bubble = document.createElement('div');
      bubble.className = `info-bubble ${type}`;
      bubble.textContent = text;
      container.appendChild(bubble);

      bubble.style.maxWidth = '200px';

      // DOM에 렌더링된 후 정확한 크기 측정
      const rect = bubble.getBoundingClientRect();
      const width = Math.min(rect.width, 200);
      const height = rect.height;

      // 버블 위치 찾기
      let placed = false;
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * (containerW - width);
        const y = Math.random() * (containerH - height);
        bubble.style.left = `${x}px`;
        bubble.style.top = `${y}px`;

        if (!checkOverlap(bubble)) {
          placed = true;
          break;
        }
      }

      if (placed) {
        bubble.classList.add('fade-in');
        bubbles.push(bubble);
      } else {
        // 공간이 없는 상태 → 가장 오래된 버블을 제거하고 다시 시도
        bubble.remove(); // 먼저 제거
        removeOldestBubble(() => {
          // 제거가 끝난 후 재귀적으로 다시 추가
          createBubble({ text, type });
        });
      }
    }

    function checkOverlap(newBubble) {
      const r1 = newBubble.getBoundingClientRect();
      return bubbles.some(b => {
        const r2 = b.getBoundingClientRect();
        return !(
          r1.right + margin < r2.left ||
          r1.left - margin > r2.right ||
          r1.bottom + margin < r2.top ||
          r1.top - margin > r2.bottom
        );
      });
    }

    /*
    function removeOldestBubble(callback) {
      const old = bubbles.shift();
      if (old) {
        old.classList.remove('fade-in');
        old.classList.add('fade-out');
        // transition-duration이 0.5s 이므로 약간 여유 있게 600ms 후 제거
        setTimeout(() => {
          old.remove();
          if (callback) callback(); // 제거 끝난 후 다음 버블 생성
        }, 600);
      } else {
        if (callback) callback(); // 아무것도 없어도 콜백은 실행
      }
    }
    */

    function removeOldestBubble(callback) {
      const old = bubbles.shift();
      if (!old) {
        if (callback) callback();
        return;
      }

      // 클래스를 바꾸기 전에 reflow를 강제로 일으켜 transition을 확실히 적용
      old.classList.remove('fade-in');
      // 트리거: 읽기 연산을 넣어 브라우저가 스타일 변경을 인식하게 함
      void old.offsetWidth;

      old.classList.add('fade-out');

      setTimeout(() => {
        old.remove();
        if (callback) callback();
      }, 600); // fade-out duration보다 살짝 여유 있게
    }

    // function start() {
    //   const interval = setInterval(() => {
    //     if (index >= sentences.length) {
    //       clearInterval(interval);
    //       return;
    //     }
    //     createBubble(sentences[index]);
    //     index++;
    //   }, 1500);
    // }

    function start() {
      setInterval(() => {
        const sentence = sentences[index % sentences.length];  // 인덱스 순환
        createBubble(sentence);
        index++;
      }, 1500);
    }

    start();

  </script>
</body>

</html>